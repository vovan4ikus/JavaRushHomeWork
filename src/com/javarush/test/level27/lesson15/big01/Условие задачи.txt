****************************************************************
Задание 5
Сейчас повар готовит блюда моментально. На самом деле готовка занимает какое-то время.
Нам нужно вычислить время приготовления всего заказа, чтобы потом подбирать рекламные ролики для этого времени.

1. Предположим, у нас известно время приготовления каждого блюда в минутах. Захардкодим его в классе Dish.
1.1. Измените создание элементов энама - Fish(25), Steak(30), Soup(15), Juice(5), Water(3);
1.2. Создайте поле private int duration с геттером.
Чтобы создать геттер, нажмите Alt+Insert и выберите пункт Getter. Далее выберите имя поля и нажмите OK(Enter).

2. Добавим возможность посчитать продолжительность приготовления всего заказа.
В какое место добавить???
2.1. Если в класс Cook, то повар сможет считать продолжительность приготовления заказа.
Чтобы другие классы могли получить эту инфу, надо будет доступиться к объекту Cook.
2.2. Если в класс Order, то имея доступ к заказу всегда можно узнать продолжительность приготовления.
Но нужно иметь доступ к объекту Order.
2.3. Выберите правильное место из п.2.1. и п.2.2. и добавьте метод int getTotalCookingTime(),
который посчитает суммарное время приготовления всех блюд в заказе.
2.4. Добавим нашему повару вывод в консоль этой информации. Пусть теперь выводится аналогичное сообщение:
Start cooking - Your order: [Soup, Juice, Water] of Tablet{number=5}, cooking time 23min

Наведем некоторые рюшечки:
3. Запустим приложение и сразу введем 'exit'. Вывод получился не очень красивым.
Сделайте так, что если в заказе нет блюд, то чтобы он не отправлялся повару. Найдите это место и реализуйте логику.
В классе Order создайте вспомогательный метод  boolean isEmpty(), который будет определять, есть ли какие либо блюда в заказе.
Подсказка: используйте одноименный метод

4. Запустим приложение и введем 'fff', 'Soup' и 'exit'. В итоге наш заказ - Your order: [Soup], а 'fff' проигнорировано.
Давай уведомим пользователя, что блюда 'fff' нет. Выведем аналогичную фразу
fff is not detected


****************************************************************
Задание 4
Что мы имеем? Повар приготовил блюда, пора их уносить, а официант не знает об этом.
Нужно уведомить официанта, что пора забирать заказ с кухни.
Ситуация аналогична предыдущему заданию, поэтому снова будем использовать паттерн Observer.

1. Создадим класс Waitor(Официант) в пакете kitchen, он будет относить заказы назад к столику. Официант будет безымянный.

2. Cook(Повар) готовит заказы, а Waitor их обрабатывает. Расставьте правильно Observer и Observable между Waitor и Cook.

3. Метод void update пусть выведет в консоль следующее:
order + " was cooked by " + cook

4. В классе-Observable перед отправкой заказа сделаем следующее:
4.1. Установим флаг setChanged()
4.2. Отправим обсерверу заказ notifyObservers(order);

5. Пишем main.
Для объекта Observable добавляем свой объект Observer. См. п.2 и описание паттерна в wikipedia
Называем повара, имя не влияет на тесты. В моем варианте - это Amigo :)

Сверим выводы в консоль. Пример моего вывода:
Your order: [Water] of Tablet{number=5}
Start cooking - Your order: [Water] of Tablet{number=5}
Your order: [Water] of Tablet{number=5} was cooked by Amigo


****************************************************************
Задание 3
Сейчас мы можем создавать заказы. Давайте сделаем, чтобы они автоматически поступали к повару.
Есть много различных способов реализации данной функциональности. Мы будем использовать средства java.
Почитайте про паттерн Observer - http://en.wikipedia.org/wiki/Observer_pattern
Он реализован в java, и мы его будем использовать.

1. Создадим класс Cook(Повар) в пакете kitchen, он будет готовить. Пусть в конструкторе приходит его имя, которое выводится методом toString.

2. Tablet создает заказы, а Cook их обрабатывает. Расставьте правильно Observer и Observable между Tablet и Cook.

3. Метод void update(Observable observable, Object arg), который необходимо реализовать, принимает два параметра.
-observable - объект, который отправил нам значение
-arg - само значение, в нашем случае - это объект Order
На данном этапе мы сымитируем обработку и выведем в консоль "Start cooking - " + order

3. Пишем main.
Для объекта Observable добавляем свой объект Observer. См. п.2 и описание паттерна в wikipedia
Называем повара, имя не влияет на тесты. В моем варианте - это Amigo :)

Сверим выводы в консоль. Пример моего вывода:
Your order: [Soup] of Tablet{number=5}
Start cooking - Your order: [Soup] of Tablet{number=5}

4. Кстати, вы сгенерировали автоматически метод toString в классе Tablet?
Если нет, то внутри класса Tablet нажмите Alt+Insert -> toString()
Результат получится примерно такой: Tablet{number=5}

5. Не забудьте сразу после создания заказа и вывода информации о нем в консоль (найдите это место в коде) сделать следующее:
5.1. Установить флаг setChanged()
5.2. Отправить обсерверу заказ notifyObservers(order);


****************************************************************
Задание 2
1. Мы много работаем с консолью. Пора создать единую точку взаимодействия.
Создайте класс ConsoleHelper с единственным BufferedReader, через который будете работать с консолью.
Запомните, этот класс не хранит никаких данных и состояний, поэтому все методы будут статическими.
Создайте в нем три метода:
-writeMessage(String message) - для вывода message в консоль
-String readString() - для чтения строки с консоли
-List<Dish> getAllDishesForOrder() - просит ползователя выбрать блюдо и добавляет его в список. Введенное 'exit' означает завершение заказа.
исключения пробрасывайте выше, на этом уровне не понятно, что с ними делать.

2. Отрефакторьте код - работа с консолью должна быть только через класс ConsoleHelper

3. Вернемся к классу Order: в нем есть ссылка на планшет, и еще есть список выбранных блюд.
Создайте поле dishes - список блюд. Инициализируйте его в конструкторе, вызвав метод getAllDishesForOrder из ConsoleHelper.

4. Перепишите метод toString в классе Order. Пусть он возвращает пустую строку, если нет блюд в заказе, иначе
вывод должен быть аналогичный примеру в порядке добавления блюд. Используйте ConsoleHelper.
Пример:
Your order: [Juice, Fish] of Tablet{number=5}

5. У нас все завязано на работу с консолью. Однако, при возникновении исключений, наше приложение умрет.
Чтобы узнать причину - добавим в Tablet статический логгер java.util.logging.Logger, инициализированный именем класса.

6. В методе createOrder класса Tablet обработаем исключения ввода-вывода.
Запишем в лог "Console is unavailable.". Уровень лога - SEVERE - это самый серьезный уровень, мы не можем работать.

7. Надо начинать тестировать наше приложение.
Добавьте в main создание планшета и создание заказа - new Tablet(5).createOrder();


****************************************************************
Задание 1

Давай напишем программу для автоматизации работы в ресторане.
Пусть задание сформулировано так - директор ресторана хочет, чтобы:
1) на каждом столике лежал планшет, через который можно будет сделать заказ
2) пока заказ готовится, на планщете показывалась реклама
3) в конце рабочего дня была возможность посмотреть различную статистику
 а) загрузки повара
 б) сумму выручки за заказы
 в) сумму выручки за показы рекламы

Мы будем разрабатывать ядро, без UI. UI ты потом сможешь дописать самостоятельно, сейчас ограничимся консольным интерфейсом.
Также мы часть данных захардкодим, ты потом сможешь прикрутить БД, и работать с ней.

Выделим несколько фич, которые будем реализовывать:
Первая:
-созданный посетителем заказ будет автоматически поступать к повару
-повар будет готовить его какое-то время и отмечать приготовленным
-после этого официант будет относить его
Вторая:
-подобрать нужные рекламные ролики из списка оплаченных
-отображение рекламных роликов во время приготовления заказа
-максимизировать прибыль от показа рекламы
Третья:
-подсчет статистики
-отображение статистики директору

Начнем с первой фичи - автоматизация обработки заказа:
Итак..
1. Создайте класс Restaurant с методом main.

2. Начнем с планшета, создадим класс Tablet, в котором создадим поле final int number - это номер планшета,
чтобы можно было однозначно установить, откуда поступил заказ, должен инициализироваться в конструкторе.

3. В классе Tablet создадим метод public void createOrder(), который будет создавать заказ из тех блюд, которые выберет пользователь.
Для этого создадим класс Order, который поместим в пакет kitchen.
Итак, что делает createOrder? Он создает заказ и выводит его данные (список блюд, об этом позднее) в консоль.

4. В классе Order (заказ) должна быть информация, относящаяся к списку выбранных пользователем блюд.
Т.е. где-то должен быть список всех блюд, и должен быть список выбранных блюд в классе Order.
Нам нужен класс Dish(Блюдо), создадим его в пакете kitchen. Пусть это будет энум с какими-то данными, например, Fish, Steak, Soup, Juice, Water

5. Чтобы пользователь мог выбрать себе блюда, нужно их все ему отобразить. Для этого в Dish создайте метод
public static String allDishesToString(), который сформирует строку из всех блюд.
Пример, "Fish, Steak, Soup, Juice, Water". Формируйте строку динамически.


